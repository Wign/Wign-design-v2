scalar Date # Date kan evt være i integer timestamp format, så det kan konverteres
scalar Year # YYYY - bare Integer er nok

# The main query method - in which we can query it for data
type Query {
  ### WORDS ###
  words: [Word!]! # All word ordered by created time
  word(word: String!): Word
  randomWord: Word # A random existing word
  requestedWords: [requestedWord]!
  requestedWord(word: String!): requestedWord
  signedWords: [signedWord]!
  signedWord(word: String!): signedWord

  ### SIGNS ###
  signs: [Sign]!
  signById(signId: ID!): Sign
  signByWord(word: String!): [Sign!]
  randomSign: Sign!

  ### USER ###
  user(id: ID!): User

  ### BUCKET ###
  # Later...

  ### LANGUAGE ###
  # Later...

  ### TAG ###
  # Later...

  ### ART / ARTIST ###
  # Later...
}

# The mutation type, that can make any mutations of the data in database
type Mutation {
  ### WORD ###
  requestWord(input: WordInput!): requestedWord
  deleteWord(wordId: ID!): Word
  editWord(wordId: ID!, input: WordInput): Word
  addAlias(wordId: ID!, input: WordInput): Word

  ### SIGN ###
  signPlayed(signId: ID!): Int! # Added one click to "play" in the video
  createSign(input: SignInput!): Sign
  editDescription(input: DescriptionInput): Sign
  flagSign(input: FlagInput): Sign
  deleteSign(signId: ID!): Sign

  ### LIKE ###
  like(userId: ID!, signId: ID!): Boolean! # Returns true if liked
  unlike(userId: ID!, signId: ID!): Boolean! # Returns false if is unliked
}

input WordInput {
  # Must have EITHER wordId OR word !
  wordId: ID
  word: String
  language: String! # Code of the text language!
  userId: ID!
}

input SignInput {
  word: WordInput
  userId: ID!
  videoUuid: String!
  signLanguage: String! # Code of the sign language!
  description: String
}

input DescriptionInput {
  signId: ID!
  userId: ID! # creator/editor
  description: String
}

input FlagInput {
  signId: ID!
  userId: ID!
  Reason: String! # One of the hardcoded possibilities
  IP: String!
  Description: String # Opt: Extra descirption of the reason
}

interface Word {
  id: ID!
  word: String!
  language: TextLanguage!
}

# Words with at least one sign
type signedWord implements Word {
  id: ID!
  word: String!
  language: TextLanguage!
  signs: [Sign!]!
  aliases: [Word!]! # Liste over alle relateret orde
}

# Words which has been requested upon
type requestedWord implements Word {
  id: ID!
  word: String!
  language: TextLanguage!
  requests: [Request!]!
}

type Sign {
  id: ID!
  videoUuid: String!
  word: Word!
  plays: Int!
  signLanguage: SignLanguage!
  creator: User!
  created: Date!
  countLikes: Int!
  isLiked(userId: ID!): Boolean!
  description: String! # Eller en selvstændig description block - afhængigt om vi ønsker at viser history over descriptions?
}

type User {
  id: ID!
  name: String!
  signs: [Sign!] # All signs created by this user
  requests: [Request!] # All requests created by this user
  buckets: [Bucket!] # All the buckets of the user
}

type Like {
  id: ID!
  sign: Sign!
  user: User!
}

interface Language {
  id: ID!
  code: String!
  name: String!
}

type SignLanguage implements Language{
  id: ID!
  code: String!
  name: String!
}

type TextLanguage implements Language{
  id: ID!
  code: String!
  name: String!
}

## Disse nedenfor kan du implementere senere hvis?
type Request {
  id: ID!
  word: Word!
  creator: User!
  created: Date!
}

type Tag {
  id: ID!
  tag: String!
  signs: [Sign!]! # Evt. kun/også liste af descriptions?
}

type Bucket {
  id: ID! # Bruge uuid her!
  title: String!
  owner: User!
  created: Date!
}

type Art {
  id: ID!
  name: String!
  filename: String!
  url: String!
  artist: Artist!
  year: Year!
}

type Artist {
  id: ID!
  name: String!
  externalUrl: String! # Url til deres hjemmeside eller lignende
  internalUrl: String! # Url til vores egen profilering-side af dem
}